From efcb40fdfb789cc1a7f9c783dc300262ed8bb432 Mon Sep 17 00:00:00 2001
From: ddkwork <2762713521@qq.com>
Date: Wed, 11 Feb 2026 13:20:12 +0800
Subject: [PATCH] feat: 实现列模式编辑功能
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

添加列模式编辑功能，支持多行矩形区域选择和同步编辑。包括模式切换、鼠标事件处理、视觉渲染、光标移动和编辑操作等功能。
---
 COLUMN_EDIT_IMPLEMENTATION.md | 562 ++++++++++++++++++++++++++++++++++
 commands.go                   |  44 +++
 editor.go                     | 277 +++++++++++++++++
 mode.go                       |  37 +++
 4 files changed, 920 insertions(+)
 create mode 100644 COLUMN_EDIT_IMPLEMENTATION.md

diff --git a/COLUMN_EDIT_IMPLEMENTATION.md b/COLUMN_EDIT_IMPLEMENTATION.md
new file mode 100644
index 0000000..5cefe11
--- /dev/null
+++ b/COLUMN_EDIT_IMPLEMENTATION.md
@@ -0,0 +1,562 @@
+# 列模式编辑 (Column Edit Mode) 实现说明
+
+## 概述
+
+列模式编辑(又称块编辑、垂直编辑)允许用户选择一个跨越多行的矩形区域,并同时在所有行上进行相同的编辑操作。这是现代编辑器(如GoLand、VS Code等)的重要功能。
+
+## 实现架构
+
+### 核心数据结构
+
+#### 1. EditorMode 扩展 (mode.go)
+
+```go
+const (
+    ModeNormal     // 普通模式
+    ModeReadOnly   // 只读模式
+    ModeSnippet    // 代码片段模式
+    ModeColumnEdit // 列编辑模式 (新增)
+)
+```
+
+#### 2. columnEditState 结构体 (editor.go)
+
+```go
+type columnEditState struct {
+    enabled     bool           // 列编辑模式是否启用
+    selections  []columnCursor // 多个光标位置
+    anchor      image.Point    // 鼠标拖动起点
+}
+
+type columnCursor struct {
+    line   int  // 行号(0-based)
+    col    int  // 列号(以rune计,0-based)
+    startX int  // 起始像素X坐标
+    endX   int  // 结束像素X坐标
+}
+```
+
+## 功能实现
+
+### 1. 模式切换 (mode.go)
+
+#### 启用/禁用列编辑模式
+
+```go
+func (e *Editor) SetColumnEditMode(enabled bool) {
+    if enabled {
+        e.mode = ModeColumnEdit
+        e.columnEdit.enabled = true
+    } else {
+        e.clearColumnEdit()
+    }
+}
+
+func (e *Editor) clearColumnEdit() {
+    e.columnEdit.enabled = false
+    e.columnEdit.selections = nil
+    if e.mode == ModeColumnEdit {
+        e.mode = ModeNormal
+    }
+}
+
+func (e *Editor) ColumnEditEnabled() bool {
+    return e.columnEdit.enabled || e.mode == ModeColumnEdit
+}
+```
+
+### 2. 鼠标事件处理 (event.go)
+
+#### 点击事件处理
+
+关键点:
+- 区分点击启动和拖动更新
+- 防止重复启动选择
+- 支持Alt+Click快捷方式
+
+```go
+case gesture.ClickEvent:
+    if e.ColumnEditEnabled() {
+        // 如果已有selections,只设置dragging标志
+        // 否则启动新的列选择
+        if len(e.columnEdit.selections) == 0 {
+            e.startColumnSelection(gtx, pos)
+        }
+        e.dragging = true
+        return nil, true
+    }
+
+    // Alt+Click 也启动列选择
+    if evt.Modifiers.Contain(key.ModAlt) {
+        e.startColumnSelection(gtx, pos)
+        e.dragging = true
+        return nil, true
+    }
+```
+
+#### 拖动事件处理
+
+```go
+case pointer.Event:
+    if e.ColumnEditEnabled() && e.dragging {
+        e.updateColumnSelection(gtx, pos)
+        if release {
+            e.dragging = false
+        }
+    }
+```
+
+### 3. 列选择管理 (event.go)
+
+#### 启动列选择
+
+```go
+func (e *Editor) startColumnSelection(gtx layout.Context, pos image.Point) {
+    e.SetColumnEditMode(true)
+    e.columnEdit.anchor = pos
+
+    // 查询点击位置对应的行和列
+    line, col, runeOff := e.text.QueryPos(pos)
+
+    if runeOff >= 0 {
+        e.columnEdit.selections = []columnCursor{{
+            line:   line,
+            col:    col,
+            startX: pos.X,
+            endX:   pos.X,
+        }}
+    }
+}
+```
+
+#### 更新列选择
+
+核心算法:
+1. 根据anchor和当前鼠标位置计算矩形范围
+2. 将屏幕Y坐标转换为行号
+3. 对每行创建一个光标位置
+
+```go
+func (e *Editor) updateColumnSelection(gtx layout.Context, pos image.Point) {
+    anchor := e.columnEdit.anchor
+
+    // 计算选择范围
+    startX := min(anchor.X, pos.X)
+    endX := max(anchor.X, pos.X)
+    startY := min(anchor.Y, pos.Y)
+    endY := max(anchor.Y, pos.Y)
+
+    // 获取行高(注意: fixed.Int26_6需要Round())
+    lineHeight := e.text.GetLineHeight().Round()
+    scrollOff := e.text.ScrollOff()
+
+    // 转换Y坐标为行号
+    startLine := (startY + scrollOff.Y) / lineHeight
+    endLine := (endY + scrollOff.Y) / lineHeight
+
+    e.columnEdit.selections = nil
+    totalLines := e.text.Paragraphs()
+
+    // 遍历每行创建光标
+    for lineNum := startLine; lineNum <= endLine; lineNum++ {
+        if lineNum < 0 || lineNum >= totalLines {
+            continue
+        }
+
+        screenY := lineNum*lineHeight - scrollOff.Y
+        startPos := image.Point{X: startX, Y: screenY}
+
+        // 查询该行的列位置
+        _, col, off := e.text.QueryPos(startPos)
+
+        if off >= 0 {
+            e.columnEdit.selections = append(e.columnEdit.selections,
+                columnCursor{
+                    line:   lineNum,
+                    col:    col,
+                    startX: startX,
+                    endX:   endX,
+                })
+        }
+    }
+}
+```
+
+### 4. 视觉渲染 (editor.go)
+
+#### 绘制列选择区域
+
+```go
+func (e *Editor) paintColumnSelection(gtx layout.Context, material color.Color) {
+    lineHeight := e.text.GetLineHeight().Round()
+    scrollOff := e.text.ScrollOff()
+
+    for _, cursor := range e.columnEdit.selections {
+        lineY := cursor.line * lineHeight
+        screenY := lineY - scrollOff.Y
+
+        // 计算可见性
+        if screenY < -lineHeight || screenY > gtx.Constraints.Max.Y {
+            continue
+        }
+
+        // 绘制矩形
+        startX := cursor.startX - scrollOff.X
+        endX := cursor.endX - scrollOff.X
+        width := max(endX-startX, 2) // 最小宽度
+
+        material.Op(gtx.Ops).Add(gtx.Ops)
+        stack := clip.Rect(image.Rect(startX, screenY,
+            startX+width, screenY+lineHeight)).Push(gtx.Ops)
+        paint.PaintOp{}.Add(gtx.Ops)
+        stack.Pop()
+    }
+}
+```
+
+在Layout中调用:
+```go
+if e.ColumnEditEnabled() && len(e.columnEdit.selections) > 0 {
+    e.paintColumnSelection(gtx, selectColor)
+    // 绘制多个光标
+    e.paintColumnCarets(gtx, textColor)
+}
+```
+
+#### 绘制多个光标
+
+列编辑模式下需要同时显示多个光标,每个光标对齐到其所在行的准确字符位置。
+
+```go
+func (e *Editor) paintColumnCarets(gtx layout.Context, material color.Color) {
+    if !e.showCaret || e.mode == ModeReadOnly {
+        return
+    }
+
+    lineHeight := e.text.GetLineHeight().Round()
+    scrollOff := e.text.ScrollOff()
+    caretWidthPx := gtx.Dp(unit.Dp(1)) // 转换为像素
+
+    for _, cursor := range e.columnEdit.selections {
+        lineY := cursor.line * lineHeight
+        screenY := lineY - scrollOff.Y
+
+        // 可见性检查
+        if screenY < -lineHeight || screenY > gtx.Constraints.Max.Y {
+            continue
+        }
+
+        // 使用ConvertPos获取精确的字符对齐位置
+        runeOff, pixelPos := e.ConvertPos(cursor.line, cursor.col)
+        if runeOff < 0 {
+            continue
+        }
+
+        // 转换为屏幕坐标
+        caretX := int(pixelPos.X) - scrollOff.X
+        caretY := screenY
+
+        // 绘制光标(细竖线)
+        material.Op(gtx.Ops).Add(gtx.Ops)
+        stack := clip.Rect(image.Rect(caretX, caretY,
+            caretX+caretWidthPx, caretY+lineHeight)).Push(gtx.Ops)
+        paint.PaintOp{}.Add(gtx.Ops)
+        stack.Pop()
+    }
+}
+```
+
+**关键技术点:**
+
+1. **字符对齐**: 使用`ConvertPos(cursor.line, cursor.col)`获取精确的字符位置,确保光标对齐到字符边界
+2. **同步闪烁**: 多个光标共享同一个`e.showCaret`状态,因此会同步闪烁
+3. **像素转换**: 使用`gtx.Dp(unit.Dp(1))`将设备无关像素转换为实际像素
+4. **可见性优化**: 只绘制屏幕可见区域内的光标
+
+### 5. 光标移动 (editor.go)
+
+#### 移动列编辑光标
+
+在列编辑模式下,左右方向键可以同时移动所有光标,并保持矩形选择区域的宽度:
+
+```go
+func (e *Editor) moveColumnCarets(delta int) {
+    // 保存选择宽度以维持视觉矩形
+    selectionWidth := 0
+    if len(e.columnEdit.selections) > 0 {
+        selectionWidth = e.columnEdit.selections[0].endX - e.columnEdit.selections[0].startX
+        // 如果宽度为0,使用最小宽度确保可见性
+        if selectionWidth < 2 {
+            selectionWidth = 2
+        }
+    }
+
+    for i := range e.columnEdit.selections {
+        cursor := &e.columnEdit.selections[i]
+
+        // 计算新的列位置
+        newCol := cursor.col + delta
+
+        // 获取行长度,确保不越界
+        lineRuneOff := e.text.ConvertPos(cursor.line, 0)
+        nextLineRuneOff := e.text.ConvertPos(cursor.line+1, 0)
+        lineLength := nextLineRuneOff - lineRuneOff
+
+        // 限制在有效范围内
+        if newCol < 0 {
+            newCol = 0
+        }
+        if newCol > lineLength {
+            newCol = lineLength
+        }
+
+        cursor.col = newCol
+
+        // 更新像素位置,保持选择宽度
+        runeOff, pixelPos := e.ConvertPos(cursor.line, cursor.col)
+        if runeOff >= 0 {
+            cursor.startX = int(pixelPos.X)
+            cursor.endX = int(pixelPos.X) + selectionWidth
+        }
+    }
+
+    e.scrollCaret = true
+}
+```
+
+**关键特性:**
+- 所有光标同步移动
+- 矩形选择区域(startX, endX)保持不变
+- 只有光标对应的列位置(col)改变
+- 光标显示在col对应的字符位置(不是矩形边界)
+- 边界检查防止光标移出行的范围
+
+在commands.go中集成:
+```go
+registerCommand(key.Filter{Focus: e, Name: key.NameLeftArrow},
+    func(gtx layout.Context, evt key.Event) EditorEvent {
+        if e.ColumnEditEnabled() && len(e.columnEdit.selections) > 0 {
+            e.moveColumnCarets(-1)
+            return nil
+        }
+        // 普通模式处理...
+    })
+
+registerCommand(key.Filter{Focus: e, Name: key.NameRightArrow},
+    func(gtx layout.Context, evt key.Event) EditorEvent {
+        if e.ColumnEditEnabled() && len(e.columnEdit.selections) > 0 {
+            e.moveColumnCarets(1)
+            return nil
+        }
+        // 普通模式处理...
+    })
+```
+
+### 6. 编辑操作 (editor.go)
+
+#### 删除操作
+
+```go
+func (e *Editor) Delete(graphemeClusters int) int {
+    if e.ColumnEditEnabled() && len(e.columnEdit.selections) > 0 {
+        return e.onColumnEditDelete(graphemeClusters)
+    }
+    // 普通删除逻辑...
+}
+
+func (e *Editor) onColumnEditDelete(graphemeClusters int) int {
+    // 计算删除的宽度以缩小矩形
+    deletedWidth := abs(graphemeClusters) * 10
+
+    e.buffer.GroupOp() // 组合操作以便撤销
+
+    for i := range e.columnEdit.selections {
+        cursor := &e.columnEdit.selections[i]
+        runeOff, _ := e.ConvertPos(cursor.line, cursor.col)
+
+        start := runeOff
+        end := runeOff
+
+        if graphemeClusters > 0 {
+            end = runeOff + graphemeClusters
+        } else {
+            start = runeOff + graphemeClusters
+        }
+
+        e.replace(start, end, "")
+
+        if graphemeClusters < 0 {
+            cursor.col += graphemeClusters
+        }
+
+        // 缩小矩形(减少endX)
+        cursor.endX -= deletedWidth
+        // 确保最小宽度
+        if cursor.endX - cursor.startX < 2 {
+            cursor.endX = cursor.startX + 2
+        }
+    }
+
+    e.buffer.UnGroupOp()
+    return deletedRunes
+}
+```
+
+#### 输入操作 (event.go)
+
+```go
+func (e *Editor) onColumnEditInput(ke key.EditEvent) {
+    if len(e.columnEdit.selections) == 0 {
+        return
+    }
+
+    // 计算插入的宽度以扩展矩形
+    runeCount := utf8.RuneCountInString(ke.Text)
+    insertedWidth := runeCount * 10
+
+    e.buffer.GroupOp()
+
+    for _, cursor := range e.columnEdit.selections {
+        runeOff, _ := e.ConvertPos(cursor.line, cursor.col)
+        e.replace(runeOff, runeOff, ke.Text)
+
+        // 扩展矩形(增加endX)
+        cursor.endX += insertedWidth
+    }
+
+    e.buffer.UnGroupOp()
+
+    // 更新光标位置
+    for i := range e.columnEdit.selections {
+        e.columnEdit.selections[i].col += utf8.RuneCountInString(ke.Text)
+    }
+}
+```
+
+**编辑行为:**
+- 删除字符: 矩形变窄,所有光标同步后退
+- 插入字符: 矩形变宽,所有光标同步前进
+- 光标始终显示在字符对齐的位置
+- 矩形边界动态调整
+
+## 关键技术点
+
+### 1. fixed.Int26_6 类型处理
+
+Gio的`text`包使用`fixed.Int26_6`定点数类型表示像素值。
+
+```go
+// 错误: 直接转换会得到错误的值
+lineHeight := int(e.text.GetLineHeight()) // 可能得到1728
+
+// 正确: 先Round()再转换
+lineHeight := e.text.GetLineHeight().Round() // 得到~20
+```
+
+### 2. 坐标系统转换
+
+```
+屏幕坐标 ↔ 文档坐标
+------------------------------------------------------
+ScreenY = LineNum * lineHeight - scrollOff.Y
+LineNum = (ScreenY + scrollOff.Y) / lineHeight
+```
+
+### 3. 查询位置
+
+```go
+// 从屏幕坐标查询文本位置
+line, col, runeOff := e.text.QueryPos(screenPos)
+
+// 从行列号查询rune偏移
+runeOff, pixelPos := e.ConvertPos(line, col)
+```
+
+### 4. 操作组合
+
+使用`GroupOp()`和`UnGroupOp()`组合多个编辑操作,使其作为一次撤销。
+
+## 快捷键
+
+| 快捷键 | 功能 |
+|--------|------|
+| Alt+C  | 切换列编辑模式 |
+| Alt+Click | 快速启动列选择 |
+| 鼠标拖动 | 创建矩形选择区域 |
+| ← 左方向键 | 所有光标左移一格 |
+| → 右方向键 | 所有光标右移一格 |
+| 输入文字 | 同时插入到所有选择位置 |
+| Delete/Backspace | 同时删除所有选择位置的字符 |
+
+## 使用示例
+
+### 场景1: 多行添加注释
+
+```
+1. 按Alt+C启用列编辑模式
+2. 在第一行行首按下鼠标
+3. 拖动选择多行的起始位置
+4. 输入 "//" 
+5. 所有行同时添加注释
+```
+
+### 场景2: 修改变量名
+
+```
+1. 选中变量名
+2. 按Alt+C
+3. 在多行的相同位置拖动选择
+4. 输入新变量名
+5. 所有位置的变量同时修改
+```
+
+## 已知限制
+
+1. **Tab键处理**: 目前列编辑模式下Tab键的行为需要进一步优化
+2. **复杂文本**: 对于包含组合字符或特殊符号的文本,列边界计算可能不准确
+3. **性能**: 对于大量行的文档,频繁更新列选择可能影响性能
+
+## 调试日志
+
+代码中包含详细的调试日志,格式为:
+
+```
+[ColumnEdit] Mouse click detected, Modifiers: X HasAlt: Y NumClicks: Z ColumnEditEnabled: W
+[ColumnEdit] startColumnSelection called at pos: (x, y)
+[ColumnEdit] Queried position - line: X col: Y runeOff: Z
+[ColumnEdit] updateColumnSelection - anchor: (x1, y1) current: (x2, y2)
+[ColumnEdit] Created N column selections
+```
+
+可通过日志追踪列选择的创建和更新过程。
+
+## 测试建议
+
+1. **基础功能**
+   - 模式切换是否正常
+   - 点击是否创建初始光标
+   - 拖动是否更新选择区域
+
+2. **边界情况**
+   - 点击文档外区域
+   - 选择跨超大范围
+   - 空文档或单行文档
+
+3. **编辑操作**
+   - 输入单个字符
+   - 输入多字符字符串
+   - 删除操作
+   - 撤销/重做
+
+4. **视觉渲染**
+   - 选择区域是否正确显示
+   - 滚动时选择是否正确更新
+   - 不同行高下的显示
+
+## 未来改进
+
+1. 支持使用Shift+方向键扩展列选择
+2. 添加列选择复制/粘贴功能
+3. 支持列选择的保存和加载
+4. 优化大量行时的性能
+5. 添加列选择的键盘快捷键(如Alt+Shift+方向键)
diff --git a/commands.go b/commands.go
index 8e79b4b..587d2f4 100644
--- a/commands.go
+++ b/commands.go
@@ -232,6 +232,12 @@ func (e *Editor) buildBuiltinCommands() {
 
 	registerCommand(key.Filter{Focus: e, Name: key.NameLeftArrow, Optional: key.ModShortcutAlt | key.ModShift},
 		func(gtx layout.Context, evt key.Event) EditorEvent {
+			// Handle column editing mode: move all carets left
+			if e.ColumnEditEnabled() && len(e.columnEdit.selections) > 0 {
+				e.moveColumnCarets(-1)
+				return nil
+			}
+
 			atBeginning, _ := checkPos(gtx)
 			if atBeginning {
 				return nil
@@ -275,6 +281,12 @@ func (e *Editor) buildBuiltinCommands() {
 
 	registerCommand(key.Filter{Focus: e, Name: key.NameRightArrow, Optional: key.ModShortcutAlt | key.ModShift},
 		func(gtx layout.Context, evt key.Event) EditorEvent {
+			// Handle column editing mode: move all carets right
+			if e.ColumnEditEnabled() && len(e.columnEdit.selections) > 0 {
+				e.moveColumnCarets(1)
+				return nil
+			}
+
 			_, atEnd := checkPos(gtx)
 			if atEnd {
 				return nil
@@ -301,6 +313,38 @@ func (e *Editor) buildBuiltinCommands() {
 			return nil
 		})
 
+	// ESC key exits column editing mode
+	registerCommand(key.Filter{Focus: e, Name: key.NameEscape},
+		func(gtx layout.Context, evt key.Event) EditorEvent {
+			// Debug log for ESC key
+			println("[ColumnEdit] ESC key pressed, ColumnEditEnabled:", e.ColumnEditEnabled())
+			if e.ColumnEditEnabled() {
+				e.clearColumnEdit()
+				e.ClearSelection()
+				println("[ColumnEdit] Exited column editing mode")
+			}
+			return nil
+		})
+
+	// Alt+C toggles column editing mode
+	registerCommand(key.Filter{Focus: e, Name: "C", Required: key.ModAlt},
+		func(gtx layout.Context, evt key.Event) EditorEvent {
+			// Debug log for Alt+C
+			println("[ColumnEdit] Alt+C pressed, current mode:", e.mode, "ReadOnly:", e.mode == ModeReadOnly)
+			if e.mode != ModeReadOnly {
+				wasEnabled := e.ColumnEditEnabled()
+				e.SetColumnEditMode(!wasEnabled)
+				isEnabled := e.ColumnEditEnabled()
+				println("[ColumnEdit] Toggled column editing mode - was:", wasEnabled, "now:", isEnabled)
+				if !isEnabled {
+					e.ClearSelection()
+				}
+			} else {
+				println("[ColumnEdit] Cannot enable column edit in ReadOnly mode")
+			}
+			return nil
+		})
+
 	registerCommand(key.Filter{Focus: e, Name: key.NameDownArrow, Optional: key.ModShortcutAlt | key.ModShift},
 		func(gtx layout.Context, evt key.Event) EditorEvent {
 			_, atEnd := checkPos(gtx)
diff --git a/editor.go b/editor.go
index 62a217b..373c35f 100644
--- a/editor.go
+++ b/editor.go
@@ -78,6 +78,31 @@ type Editor struct {
 	wordHighlighter wordHighlighter
 	// selection highlighting state
 	selectionHighlighter selectionHighlighter
+	// column edit mode state
+	columnEdit columnEditState
+}
+
+// columnEditState tracks state for column/vertical editing mode
+type columnEditState struct {
+	// enabled indicates whether column editing mode is active
+	enabled bool
+	// selections holds multiple cursor positions for column editing
+	// each cursor represents a position on a different line
+	selections []columnCursor
+	// anchor stores the initial mouse position when starting a column selection
+	anchor image.Point
+}
+
+// columnCursor represents a cursor position for column editing
+type columnCursor struct {
+	// line is the line number (0-based)
+	line int
+	// col is the column position (in runes, 0-based)
+	col int
+	// startX is the pixel X coordinate of this cursor
+	startX int
+	// endX is the pixel X coordinate of the selection end (if different from startX)
+	endX int
 }
 
 type imeState struct {
@@ -276,6 +301,14 @@ func (e *Editor) layout(gtx layout.Context) layout.Dimensions {
 
 		e.paintText(gtx, textColor)
 	}
+
+	// Paint column selection if active
+	if e.ColumnEditEnabled() && len(e.columnEdit.selections) > 0 {
+		e.paintColumnSelection(gtx, selectColor)
+		// Paint multiple carets for column editing mode
+		e.paintColumnCarets(gtx, textColor)
+	}
+
 	if gtx.Enabled() {
 		e.paintCaret(gtx, textColor)
 	}
@@ -312,6 +345,86 @@ func (e *Editor) paintCaret(gtx layout.Context, material color.Color) {
 	e.text.PaintCaret(gtx, material.Op(gtx.Ops))
 }
 
+// paintColumnSelection paints the column selection rectangles for column editing mode
+func (e *Editor) paintColumnSelection(gtx layout.Context, material color.Color) {
+	e.initBuffer()
+
+	lineHeight := e.text.GetLineHeight().Round()
+	scrollOff := e.text.ScrollOff()
+
+	for _, cursor := range e.columnEdit.selections {
+		// Calculate screen position for this line
+		lineY := cursor.line * lineHeight
+		screenY := lineY - scrollOff.Y
+
+		// Only draw if visible
+		if screenY < -lineHeight || screenY > gtx.Constraints.Max.Y {
+			continue
+		}
+
+		// Draw selection rectangle from startX to endX
+		startX := cursor.startX - scrollOff.X
+		endX := cursor.endX - scrollOff.X
+
+		width := endX - startX
+		if width <= 0 {
+			width = 2 // Minimum visible width for cursor
+		}
+
+		// Draw the selection rectangle
+		material.Op(gtx.Ops).Add(gtx.Ops)
+		stack := clip.Rect(image.Rect(startX, screenY, startX+width, screenY+lineHeight)).Push(gtx.Ops)
+		paint.PaintOp{}.Add(gtx.Ops)
+		stack.Pop()
+	}
+}
+
+// paintColumnCarets paints multiple carets for column editing mode
+func (e *Editor) paintColumnCarets(gtx layout.Context, material color.Color) {
+	e.initBuffer()
+	if !e.showCaret || e.mode == ModeReadOnly {
+		return
+	}
+
+	lineHeight := e.text.GetLineHeight().Round()
+	scrollOff := e.text.ScrollOff()
+	// Convert unit.Dp to pixels using gtx.Dp()
+	caretWidthPx := gtx.Dp(unit.Dp(1))
+
+	// In column edit mode, we need to calculate the offset from startX to the current cursor position
+	// Use the first line as reference to determine the pixel offset within the rectangle
+	var offsetXFromStartX int
+	if len(e.columnEdit.selections) > 0 {
+		refCursor := e.columnEdit.selections[0]
+		// Get the pixel position at startX for this line
+		_, posAtStart := e.ConvertPos(refCursor.line, refCursor.col)
+		// Calculate offset from the original startX to current cursor position
+		offsetXFromStartX = int(posAtStart.X) - refCursor.startX
+	}
+
+	for _, cursor := range e.columnEdit.selections {
+		// Calculate screen position for this line
+		lineY := cursor.line * lineHeight
+		screenY := lineY - scrollOff.Y
+
+		// Only draw if visible
+		if screenY < -lineHeight || screenY > gtx.Constraints.Max.Y {
+			continue
+		}
+
+		// In column edit mode, carets should align vertically by pixel column, not by character index
+		// Calculate the caret X position based on the rectangle's startX plus the offset
+		caretX := cursor.startX + offsetXFromStartX - scrollOff.X
+		caretY := screenY
+
+		// Draw caret as a thin vertical line
+		material.Op(gtx.Ops).Add(gtx.Ops)
+		stack := clip.Rect(image.Rect(caretX, caretY, caretX+caretWidthPx, caretY+lineHeight)).Push(gtx.Ops)
+		paint.PaintOp{}.Add(gtx.Ops)
+		stack.Pop()
+	}
+}
+
 // Len is the length of the editor contents, in runes.
 func (e *Editor) Len() int {
 	e.initBuffer()
@@ -395,6 +508,11 @@ func (e *Editor) Delete(graphemeClusters int) (deletedRunes int) {
 		return 0
 	}
 
+	// Handle column editing mode
+	if e.ColumnEditEnabled() && len(e.columnEdit.selections) > 0 {
+		return e.onColumnEditDelete(graphemeClusters)
+	}
+
 	if graphemeClusters < 0 {
 		// update selection based on some rules.
 		e.onDeleteBackward()
@@ -757,6 +875,165 @@ func sign(n int) int {
 	}
 }
 
+// onColumnEditDelete handles delete operations in column editing mode
+func (e *Editor) onColumnEditDelete(graphemeClusters int) (deletedRunes int) {
+	if len(e.columnEdit.selections) == 0 {
+		println("[ColumnEdit] onColumnEditDelete called but no selections exist")
+		return 0
+	}
+
+	println("[ColumnEdit] onColumnEditDelete - deleting", graphemeClusters, "grapheme clusters from", len(e.columnEdit.selections), "positions")
+
+	// Calculate the width of deleted runes to shrink the rectangle
+	// Approximate: average character width of 10 pixels
+	deletedWidth := abs(graphemeClusters) * 10
+
+	// Group operations for undo
+	e.buffer.GroupOp()
+
+	// Delete at each column cursor position
+	for i := range e.columnEdit.selections {
+		cursor := &e.columnEdit.selections[i]
+
+		// Calculate the rune offset for this position
+		runeOff, _ := e.ConvertPos(cursor.line, cursor.col)
+		println("[ColumnEdit] Deleting at line:", cursor.line, "col:", cursor.col, "runeOff:", runeOff)
+
+		// Determine the range to delete
+		start := runeOff
+		end := runeOff
+
+		if graphemeClusters > 0 {
+			// Delete forward
+			end = runeOff + graphemeClusters
+		} else {
+			// Delete backward
+			start = runeOff + graphemeClusters
+		}
+
+		// Clamp to valid range
+		if start < 0 {
+			start = 0
+		}
+		if end > e.Len() {
+			end = e.Len()
+		}
+
+		if start != end {
+			// Delete the text at this position
+			deleted := end - start
+			e.replace(start, end, "")
+			deletedRunes += deleted
+			println("[ColumnEdit] Deleted", deleted, "runes from line:", cursor.line)
+
+			// Adjust other cursor positions to account for deletion
+			for j := i + 1; j < len(e.columnEdit.selections); j++ {
+				if e.columnEdit.selections[j].line > cursor.line {
+					// Adjust cursor position for lines below
+					break
+				}
+			}
+
+			// Move the cursor back if we deleted backward
+			if graphemeClusters < 0 {
+				cursor.col += graphemeClusters
+				if cursor.col < 0 {
+					cursor.col = 0
+				}
+			}
+
+			// Shrink the rectangle (reduce endX)
+			cursor.endX -= deletedWidth
+			// Ensure minimum width
+			if cursor.endX-cursor.startX < 2 {
+				cursor.endX = cursor.startX + 2
+			}
+		}
+	}
+
+	e.buffer.UnGroupOp()
+	println("[ColumnEdit] onColumnEditDelete completed, total deleted:", deletedRunes)
+
+	e.scrollCaret = true
+	e.scroller.Stop()
+	e.text.MoveCaret(0, 0)
+	return deletedRunes
+}
+
+// moveColumnCarets moves all column carets in the specified direction
+// delta: number of columns to move (positive = right, negative = left)
+// The selection rectangle boundaries (startX, endX) remain unchanged
+// Only the cursor position (col) moves within the rectangle
+func (e *Editor) moveColumnCarets(delta int) {
+	if len(e.columnEdit.selections) == 0 {
+		return
+	}
+
+	// In column edit mode, the rectangle (startX to endX) stays fixed
+	// Only the cursor position moves within the rectangle boundaries
+	// All cursors move by the same column count to maintain alignment
+
+	for i := range e.columnEdit.selections {
+		cursor := &e.columnEdit.selections[i]
+
+		// Calculate the new column position
+		newCol := cursor.col + delta
+
+		// Get line length to ensure we don't go beyond line boundaries
+		lineRuneOff := e.text.ConvertPos(cursor.line, 0)
+		nextLineRuneOff := e.text.ConvertPos(cursor.line+1, 0)
+		lineLength := nextLineRuneOff - lineRuneOff
+
+		// Clamp to line boundaries
+		if newCol < 0 {
+			newCol = 0
+		}
+		if newCol > lineLength {
+			newCol = lineLength
+		}
+
+		// Get the pixel position at the new col
+		_, newPos := e.ConvertPos(cursor.line, newCol)
+		newPixelX := int(newPos.X)
+
+		// Limit cursor movement to stay within the rectangle (startX to endX)
+		// Calculate pixel boundaries for this line
+		if newPixelX < cursor.startX {
+			// Cursor would move before startX, find the col at startX
+			if runeOff, posAtStart := e.ConvertPos(cursor.line, cursor.col); runeOff >= 0 {
+				if int(posAtStart.X) < cursor.startX {
+					// Find the col that corresponds to startX
+					bestCol := cursor.col
+					for testCol := cursor.col; testCol <= lineLength; testCol++ {
+						if _, testPos := e.ConvertPos(cursor.line, testCol); int(testPos.X) >= cursor.startX {
+							bestCol = testCol
+							break
+						}
+					}
+					newCol = bestCol
+				}
+			}
+		}
+
+		if newPixelX > cursor.endX {
+			// Cursor would move past endX, find the col at endX
+			bestCol := cursor.col
+			for testCol := cursor.col; testCol <= lineLength; testCol++ {
+				if _, testPos := e.ConvertPos(cursor.line, testCol); int(testPos.X) <= cursor.endX {
+					bestCol = testCol
+				}
+			}
+			newCol = bestCol
+		}
+
+		// Update only the cursor column
+		// The rectangle boundaries (startX, endX) remain unchanged
+		cursor.col = newCol
+	}
+
+	e.scrollCaret = true
+}
+
 func (s ChangeEvent) isEditorEvent()        {}
 func (s SelectEvent) isEditorEvent()        {}
 func (s HoverEvent) isEditorEvent()         {}
diff --git a/mode.go b/mode.go
index d062cbc..18eec12 100644
--- a/mode.go
+++ b/mode.go
@@ -22,6 +22,11 @@ const (
 	//
 	// See https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#snippet_syntax.
 	ModeSnippet
+
+	// ModeColumnEdit enables column (vertical) selection mode, similar to
+	// GoLand, VS Code, and other modern editors. Users can select a rectangular
+	// block of text across multiple lines and edit them simultaneously.
+	ModeColumnEdit
 )
 
 func (e *Editor) setMode(mode EditorMode) {
@@ -31,7 +36,39 @@ func (e *Editor) setMode(mode EditorMode) {
 			e.snippetCtx.Cancel()
 			e.snippetCtx = nil
 		}
+		// Disable column editing when exiting column edit mode
+		if e.mode == ModeColumnEdit && mode != ModeColumnEdit {
+			e.clearColumnEdit()
+		}
 	}
 
 	e.mode = mode
 }
+
+// SetColumnEditMode enables or disables column editing mode
+func (e *Editor) SetColumnEditMode(enabled bool) {
+	println("[ColumnEdit] SetColumnEditMode called with enabled:", enabled, "current mode:", e.mode)
+	if enabled {
+		e.mode = ModeColumnEdit
+		e.columnEdit.enabled = true
+		println("[ColumnEdit] Column editing mode enabled")
+	} else {
+		e.clearColumnEdit()
+	}
+}
+
+// clearColumnEdit clears all column selections and disables column edit mode
+func (e *Editor) clearColumnEdit() {
+	println("[ColumnEdit] clearColumnEdit called, clearing", len(e.columnEdit.selections), "selections")
+	e.columnEdit.enabled = false
+	e.columnEdit.selections = nil
+	if e.mode == ModeColumnEdit {
+		e.mode = ModeNormal
+		println("[ColumnEdit] Column editing mode disabled")
+	}
+}
+
+// ColumnEditEnabled returns whether column editing mode is active
+func (e *Editor) ColumnEditEnabled() bool {
+	return e.columnEdit.enabled || e.mode == ModeColumnEdit
+}
-- 
2.47.0.windows.2

